#!/usr/bin/python3.9

from knasLogging import KNasLogging
from knasConfFile import KNasConfFile
from knasDataset import KnasDatasetKmnist
from knasModel import KNasModel
from knasEA import KNasEA

from argparse import ArgumentParser

from random import choices

from os import path


class KNas:
	'''
		This class has implemented the Neural Architecture Search through using
		evolutionary methods.
	'''
	def __init__(self):

		# Configuration file path
		self.confFilePath = str()

		# KNas logging module handler
		self.logModHand = KNasLogging()

		# KNas dataset module
		self.datasetModule = KnasDatasetKmnist()

		# KNas configuration file module handler
		self.confModHand = KNasConfFile()

		# KNas EA algorithm handler
		self.eaAlgo = None

		# KNas parameters
		self.knasParams=dict()


	def knas_argument_parser(self):
		'''
			This function has implemented the terminal argument parser of the KNAS
		'''
		
		knasArgParser=ArgumentParser(description='KNAS Program Help')

		knasArgParser.add_argument('-f','--file',  type=str, nargs=1,help='Specify A Config File Name')

		args = knasArgParser.parse_args()

		if args.file:

			self.confFilePath = args.file[0]

			if not path.exists(self.confFilePath):
				self.logModHand.knas_log_message(self.logModHand.loggingCodes['CONFIG_FILE_NOT_FOUND'],'ERR')
				exit(1)

		else:
			self.logModHand.knas_log_message(self.logModHand.loggingCodes['CONFIG_FILE_NOT_SPECIFIED'],'ERR')
			exit(1)


	def knas_parse_conig_file(self):
		'''
			This function will parse the configuration file
		'''

		fhandle=open(self.confFilePath)

		fileLines=fhandle.readlines()

		fhandle.close()


		for lineNum,line in enumerate(fileLines):

			line=line.strip()

			# Line number starts from zero, to handle this, we increment it 
			# to adjust it to start from one.
			lineNum+=1

			if line:

				if line.startswith('#'):
					continue

				# TODO inline function return
				value= self.confModHand.get_max_cnn_layer_value(line)

				if (value): 
					self.knasParams['MAX_CN_LAYERS']= int(value)
					continue

				value= self.confModHand.get_batchSize_value(line)

				if (value): 
					self.knasParams['BATCH_SIZE']= int(value)
					continue


				value= self.confModHand.get_epochs_value(line)

				if (value): 
					self.knasParams['EPOCHS']= int(value)
					continue

				value= self.confModHand.get_trainsplit_value(line)

				if (value): 
					self.knasParams['TRAIN_SPLIT']= float(value)
					continue

				value= self.confModHand.get_device_value(line)

				if (value): 
					self.knasParams['DEVICE']= value
					continue


				value=self.confModHand.get_trainRootDir_value(line)
				if value:
					self.knasParams['TRAIN_ROOT_DIR']=value
					continue

				value=self.confModHand.get_testRootDir_value(line)
				if value:
					self.knasParams['TEST_ROOT_DIR']=value
					continue

				value=self.confModHand.get_splitseed_value(line)
				if value:
					self.knasParams['SPLIT_SEED']=int(value)
					continue



				self.logModHand.knas_log_message(self.logModHand.loggingCodes['CONFIG_FILE_DEF_ERR'],'ERR',lineNum)
				exit(1)


	def start_evaluation(self):
		'''
			This is the main function of the KNAS program. This will start the
			EA algorithm and use the KNAS model classes to evaluate each individual and so on.
		'''
		


		# First set the EA algorithm handler
		self.eaAlgo = KNasEA(self.datasetModule,self.knasParams)


		# Initial population of the process
		population=self.eaAlgo.knasea_generate_initial_population()


		# Population size
		popSize = len(population)

		# Evaluating the initial population
		# population = self.eaAlgo.knasea_calculate_fitness(population)



		# Generation count for this evaluation is the termination condition

		for i in range(self.eaAlgo.genNum):

			print("GEN: ",i)
			

			'''
				Selection
			'''

			# Choose two individuals randomly from the population
			ind1 , ind2 = tuple(choices(population,k=2))

			'''
				Crossover
			'''
			off1, off2 = self.eaAlgo.knasea_crossover(ind1,ind2)

			# exit(0)
			print("Crossover finished")
			'''
				Mutation
			'''
			# off1, off2 = self.eaAlgo.knasea_mutation(off1,off2)

			
			# Evaluating the offsprings as members of a short time population
			offsPopulation = self.eaAlgo.knasea_calculate_fitness([off1,off2])

			exit(0)

			# Add offsprings to the population
			population+= offsPopulation



			'''
				Surivivol selection
			'''

			# Sorting the population based on the fitness value first, and then
			# select the population size individuals from the population
			population = sorted(population,key=lambda ind: ind.fitnessVal)[:popSize]



		# EA algorithm finished, the first individual is the one with
		# the highest fitness value
		









		
	





if __name__ == "__main__":



	# Creating the KNAS program instance
	knasObj=KNas()

	# Calling the argument reader
	knasObj.knas_argument_parser()

	# Parsing the configuration file
	knasObj.knas_parse_conig_file()

	# Starting the evaluation process
	knasObj.start_evaluation()
	
	